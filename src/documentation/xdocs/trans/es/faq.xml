<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE faqs PUBLIC "-//APACHE//DTD FAQ V1.1//EN" "./dtd/faq-v11.dtd">

<faqs title="Preguntas Más Frecuentes (FAQ)">
    <faq>
        <question>
          ¿Qué es el "eventmodel" (modelo de evento) de HSSF?
        </question>
        <answer>
              <p> El paquete "eventmodel" de HSSF es un nuevo API para la lectura más eficiente de ficheros
              XML. Requiere mayor conocimiento por parte del usuario, pero reduce el consumo de memoria a
              una décima parte. Está basado en el modelo de eventos AWT en combinación con SAX. Si necesita
              acceso de sólo-lectura a un fichero XML determinado, esta es la mejor manera de hacerlo.</p>
        </answer>

    </faq>
    <faq>
        <question>
          ¿Por qué no puedo leer el documento que creé utilizando Star Office 5.1?
        </question>
        <answer>
              <p>Star Office 5.1 escribe algunos registros utilizando el viejo estándar BIFF.
              Esto provoca algunos problemas con POI que sólo soporta BIFF8.</p>
        </answer>
    </faq>
    <faq>
        <question>
            ¿Por qué recibo una excepción cada vez que intento leer mi hoja de cálculo?
        </question>
        <answer>
            <p>Es posible que su hoja de cálculo contenga alguna característica que no esté
            soportada actualmente por HSSF. Por ejemplo - hojas de cálculo que contengan
            celdas con formato RTF (rich text) no están soportadas actualmente.</p>
        </answer>
    </faq>
    <faq>
        <question>
            ¿Soporta HSSF hojas de cálculo protegidas?
        </question>
        <answer>
            <p>Al proteger una hoja de cálculo, ésta se cifra. No tocaremos el cifrado, porque no
            tenemos el suficiente conocimiento legal y no estamos seguros de las implicaciones que
            conllevaría el intentar implementar esto. Si desea intentarlo, es libre de hacerlo y
            de añadirlo como un módulo enchufable (plugin). Sin embargo, no lo guardaremos aquí.</p>
        </answer>
    </faq>
    <faq>
        <question>
            ¿Cómo se sabe si un campo contiene una fecha con HSSF?
        </question>
        <answer>
            <p>Excel almacena las fechas como números. Así la única manera para determinar
            si una celda está realmente almacenada como una fecha consiste en mirar su formato.
            Hay un método de ayuda (helper) en HSSFDateUtil (desde la distribución 1.7.0-dev)
            que lo comprueba. Gracias a Jason Hoffman por proporcionar la solución.</p>
            <source>

case HSSFCell.CELL_TYPE_NUMERIC:
                  double d = cell.getNumericCellValue();
                  // test if a date!
                             if (HSSFDateUtil.isCellDateFormatted(cell)) {
                    // format in form of M/D/YY
                    cal.setTime(HSSFDateUtil.getJavaDate(d));
                    cellText =
                      (String.valueOf(cal.get(Calendar.YEAR))).substring(2);
                    cellText = cal.get(Calendar.MONTH)+1 + "/" +
                               cal.get(Calendar.DAY_OF_MONTH) + "/" +
                               cellText;
                  }

            </source>
        </answer>
    </faq>
    <faq>
        <question>
            Estoy intentando ver un fichero XLS enviado como flujo (stream) desde un servlet y tengo
            complicaciones. ¿Cuál es el problema?
        </question>
        <answer>
            <p>
            El problema normalmente se manifiesta como un montón de caracteres basura
            en la pantalla. El problema persiste incluso aunque hayas configurado el tipo mime
            correcto.
            </p>
            <p>
            La respuesta breve es: no dependas de IE para mostrar un fichero binario. 
            Escribe un documento adjunto como es debido si lo envías a través de un servlet. 
            Toda versión de IE tiene diferentes fallos (bugs) en este sentido.
            </p>
            <p>
            El problema en la mayoría de las versiones de IE reside en que no utiliza el tipo mime
            de la respuesta HTTP para determinar el tipo de fichero; en su lugar utiliza la extensión
            del fichero en la petición. Así podría añadir un <strong>.xls</strong> a su cadena de petición.
            Por ejemplo: <em>http://yourserver.com/myServelet.xls?param1=xx</em>. Esto se consigue
            fácilmente a través del mapeo de URL en cualquier contenedor servlet. A veces una
            petición como
                <em>http://yourserver.com/myServelet?param1=xx&amp;dummy=file.xls</em> 
            también funciona.
            </p>
            <p>
            Para garantizar la correcta apertura del fichero en Excel desde IE, escribe
            tu fichero a un fichero temporal bajo su raiz web desde tu servlet. Envía entonces
            una respuesta http al navegador para que haga una redirección en el lado del cliente
            a tu fichero temporal. (Si haces una redirección en el lado del servidor utilizando
            RequestDispatcher, tendrás que añadir .xls a la petición como se ha mendionado más
            arriba)
            </p>
            <p>
            Date cuenta de que cuando pides un documento que se abre con un manejador externo,
            IE a veces realiza dos peticiones al servidor web. Así que si tu proceso generador
            es pesado, tiene sentido escribir a un fichero temporal, para que peticiones
            múltiples utilicen el fichero estático.
            </p>
            <p>
            Nada de esto pertenece a Excel. El mismo problema ocurre cuando intentas general
            cualquier fichero binario dinámicamente a un cliente IE. Por ejemplo, si generas
            ficheros pdf utilizando
                <link href="http://xml.apache.org/fop">FOP</link>,
                te encontrarás con los mismos problemas.
            </p>
            <!-- Gracias a Avik por la respuesta -->
        </answer>
    </faq>
    <faq>
        <question>
            Quiero dar formato a una celda (Data format of a cell) de una hoja excel como
            ###,###,###.#### o ###,###,###.0000. ¿Es posible hacer esto con POI?
        </question>
        <answer>
            <p>
                HSSF no soporta todavía formatos de datos personalizados, sin embargo,
                debería ser una facilidad razonablemente sencilla de añadir y aceptaremos
                gustosos contribuciones en este área.
            </p>
            <p>
                Estos son los formatos incluidos que soporta:
            </p>
            <p>
            <link href="http://jakarta.apache.org/poi/javadocs/javasrc/org/apache/poi/hssf/usermodel/HSSFDataFormat_java.html#HSSFDataFormat">http://jakarta.apache.org/poi/javadocs/javasrc/org/apache/poi/hssf/usermodel/HSSFDataFormat_java.html#HSSFDataFormat</link>
            </p>
        </answer>
    </faq>
    <faq>
        <question>
            ¿Cómo añado un borde alrededor de una celda unida (merged)?
        </question>
        <answer>
            <p>
            Añade celdas vacías alrededor de donde las celdas hubieran estado normalmente y
            configura los bordes individualmente para cada celda.
            Probablemente mejoraremos HSSF en el futuro para facilitar este proceso.
            </p>
        </answer>
    </faq>
    <faq>
        <question>
            Intenté escribir valores en celdas así como cambiar el nombre de la hoja Excel
            en mi lengua nativa, pero no pude hacerlo. :(
        </question>
        <answer>
            <p>
            Por defecto HSSF utiliza valores de celdas y nombres de hoja en unicode comprimido,
            asi que para soportar la localización deberías utilizar Unicode.
            Para hacerlo deberías configurarlo manualmente:
            </p>
            <source>

                //
                // para el nombre de la hoja
                //
                HSSFWorkbook wb = new HSSFWorkbook();
                HSSFSheet s = wb.createSheet();
                wb.setSheetName( 0, "SomeUnicodeName", HSSFWorkbook.ENCODING_UTF_16 );


                //
                // para el valor de la celda
                //
                HSSFRow r = s.createRow( 0 );
                HSSFCell c = r.createCell( (short)0 );
                c.setCellType( HSSFCell.CELL_TYPE_STRING );
                c.setEncoding( HSSFCell.ENCODING_UTF_16 );
                c.setCellValue( "\u0422\u0435\u0441\u0442\u043E\u0432\u0430\u044F" );

            </source>
            <p>
            Asegúrate de que haces la llamada a setEncoding() antes de llamar a setCellValue(),
            si no, lo que le pases no será interpretado correctamente.
            </p>
        </answer>
    </faq>
</faqs>
