/* ====================================================================
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
==================================================================== */
package org.apache.poi.xssf.streaming.reader;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.List;
import java.util.Map;

import javax.xml.namespace.QName;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.Characters;
import javax.xml.stream.events.EndElement;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;

import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DataFormatter;
import org.apache.poi.xssf.model.SharedStringsTable;
import org.apache.poi.xssf.model.StylesTable;
import org.apache.poi.xssf.streaming.value.BooleanValue;
import org.apache.poi.xssf.streaming.value.NumericValue;
import org.apache.poi.xssf.streaming.value.PlainStringValue;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFRichTextString;

/**
 * Handler class that handles the event generated by StAX parser
 *
 */
public class StreamedSheetEventHandler {

    private boolean isEndOfRow = false;
    private boolean isRow = false;
    // private boolean mergeCell = false;

    private String formatString = null;
    private int formatIndex = 0;
    private String cellContentType;
    private int rowNumber = 0;
    private int numberOfColumns = 0;
    private List<String> cellPositions = null;
    private String currentCellPosition = null;
    private int previousCellIndex = -1;
    // private List<String> mergeList = null; //merge cell not supported right
    // now. Complexity involved if multiple rows are merged.

    private SharedStringsTable sharedStringsTable;
    private StylesTable stylesTable;

    private DataFormatter formatter = new DataFormatter();
    private Map<String, String> attributes = new HashMap<String, String>();
    private StringBuffer sb = new StringBuffer(250);
    private List<String> dateFormatsAry = new ArrayList<String>();

    private StreamedRow row;
    private StreamedCell cell;

    private final String dateFormat = "m/d/yy|DD/MM/YY|[$-F800]dddd\\,\\ mmmm\\ dd\\,\\ yyyy|m/d;@|m/d/yy;@|mm/dd/yy;@|"
            + "[$-409]d\\-mmm;@|[$-409]d\\-mmm\\-yy;@|[$-409]dd\\-mmm\\-yy;@|[$-409]mmm\\-yy;@|[$-409]mmmm\\-yy;@|"
            + "[$-409]mmmm\\ d\\,\\ yyyy;@|[$-409]m/d/yy\\ h:mm\\ AM/PM;@|m/d/yy\\ h:mm;@|[$-409]mmmmm;@|"
            + "[$-409]mmmmm\\-yy;@|m/d/yyyy;@|[$-409]d\\-mmm\\-yyyy;@|[$-F400]h:mm:ss\\ AM/PM|"
            + "h:mm;@|[$-409]h:mm\\ AM/PM;@|h:mm:ss;@|[$-409]h:mm:ss\\ AM/PM;@|mm:ss.0;@|[h]:mm:ss;@|"
            + "[$-409]m/d/yy\\ h:mm\\ AM/PM;@|DD/MM/YYYY";

    private static final String DEFAULT_CELL_TYPE = "DEFAULT";
    private static final String STRING_CELL_TYPE = "STRING";
    private static final String BOOLEAN_CELL_TYPE = "BOOLEAN";
    private static final String DATE_CELL_TYPE = "DATE";
    private static final String FORMULA_CELL_TYPE = "FORMULA";
    private static final String NUMERIC_CELL_TYPE = "NUMERIC";

    /**
     * Constructor
     * 
     * @param sharedStringsTable
     * @param stylesTable
     */
    public StreamedSheetEventHandler(SharedStringsTable sharedStringsTable, StylesTable stylesTable) {
        this.sharedStringsTable = sharedStringsTable;
        this.stylesTable = stylesTable;
        /*
         * try{ properties.load(getClass().getClassLoader().getResourceAsStream(
         * "excelreader.properties")); }catch(Exception e){ e.printStackTrace();
         * }
         */

        /*
         * if(properties.get("date.formatStrings") != null){ dateFormat =
         * properties.get("date.formatStrings").toString(); }
         */

        dateFormatsAry.addAll(Arrays.asList(dateFormat.split("\\|")));

    }

    /**
     * Handler method for handling the event generated for StAX parser. For each
     * XML event(Start Tag, End Tag & Characters), StAX parser will generate
     * event. This event will be handled by this method. Attributes of each
     * element are put in a map with key as attribute and value as attribute
     * value.
     * 
     * @param event
     */
    public void handleEvent(XMLEvent event) {
        switch (event.getEventType()) {
        case XMLEvent.START_ELEMENT:
            StartElement startElement = event.asStartElement();
            QName startName = startElement.getName();
            String name = startName.getLocalPart();
            Iterator<Attribute> iterator = startElement.getAttributes();
            while (iterator.hasNext()) {
                Attribute attribute = iterator.next();
                attributes.put(attribute.getName().getLocalPart(), attribute.getValue());
            }
            if ((name.trim().equals("row")) && (attributes.size() > 0)) {
                isRow = true;
            }

            /*
             * else if(name.trim().equals("mergeCell")){ mergeCell = true; }
             * 
             * if(isRow || mergeCell){ startElement(name); }
             */

            if (isRow) {
                startElement(name);
            }
            break;
        case XMLEvent.CHARACTERS:
            Characters chars = event.asCharacters();
            if (isRow) {
                characters(chars.getData());
            }
            break;
        case XMLEvent.END_ELEMENT:
            EndElement endElement = event.asEndElement();
            QName endName = endElement.getName();
            String endTageName = endName.getLocalPart();
            endElement(endTageName);
            attributes.clear();
            break;
        }
    }

    /**
     * All the start element events are handled here. It identifies the things
     * like rowNumber, cell content type etc
     * 
     * @param name
     */
    private void startElement(String name) {
        if (name.equals("row")) {
            previousCellIndex = -1;
            isEndOfRow = false;
            rowNumber = (Integer.parseInt(attributes.get("r")) - 1);
            row = new StreamedRow(rowNumber);
            if (rowNumber == 0) {
                cellPositions = new ArrayList<String>();
            }
        } else if (name.equals("c")) {
            String cellPosition = attributes.get("r").toUpperCase(Locale.ROOT);
            cellPosition = cellPosition.replaceAll(String.valueOf(rowNumber + 1), "").trim();
            currentCellPosition = cellPosition;
            if (rowNumber == 0) {
                numberOfColumns++;
                cellPositions.add(cellPosition);
            }

            cellContentType = getCellContentType();
        } else if (name.equals("f")) {
            cellContentType = FORMULA_CELL_TYPE;
        }

        /*
         * else if(name.equals("mergeCell")){ if(mergeList == null){ mergeList =
         * } }
         */
    }

    /**
     * This method is invoked on end element event. Mostly used for setting the
     * default values before handling next start element. All data captured in
     * characters event are stored here. Data will be stored only on reaching
     * the end element.
     * 
     * @param name
     */
    private void endElement(String name) {
        if (name.equals("c")) {
            if (isRow) {
                storeData(sb.toString());
            }
            cellContentType = DEFAULT_CELL_TYPE;
            formatString = null;
            formatIndex = 0;
            currentCellPosition = null;
            previousCellIndex++;
            sb.delete(0, sb.length());
        } else if (name.equals("row")) {
            isEndOfRow = true;
            isRow = false;
        } else if (name.equals("f")) {
            cellContentType = DEFAULT_CELL_TYPE;
        }

        /*
         * else if(name.equals("mergeCell")){ mergeCell = false; }
         */
    }

    /**
     * Captures the data
     * 
     * @param data
     */
    private void characters(String data) {
        if (!(cellContentType.equals(FORMULA_CELL_TYPE))) {
            sb.append(data);
        }
    }

    /**
     * Creates cells and store data
     * 
     * @param data cell data
     */
    private void storeData(final String data) {
        String formattedData = data;
        if (!(cellContentType.equals(FORMULA_CELL_TYPE))) {
            if (cellContentType.equals(STRING_CELL_TYPE)) {
                formattedData = getStringData(formattedData);
            } else if (cellContentType.equals(DATE_CELL_TYPE)) {
                formattedData = getDateAsString(formattedData);
            } else if (cellContentType.equals(BOOLEAN_CELL_TYPE)) {
                if (formattedData.trim().equals("1")) {
                    formattedData = "TRUE";
                } else if (formattedData.trim().equals("0")) {
                    formattedData = "FALSE";
                } else if (formattedData.trim().equals("")) {
                    formattedData = null;
                } else {
                    try {
                        int value = Integer.parseInt(formattedData);
                        if (value > 0) {
                            formattedData = "TRUE";
                        }
                    } catch (Exception e) {
                        formattedData = null;
                    }
                }
            }

            if (cellPositions != null) {
                fillEmptyCells();
            }

            cell = new StreamedCell(row);
            cell.setColumnIndex(previousCellIndex + 1);
            if (formattedData == null || formattedData.trim().isEmpty()) {
                cell.setCellType(CellType.BLANK);
            } else if (cellContentType.equals(BOOLEAN_CELL_TYPE)) {
                BooleanValue bv = new BooleanValue();
                if(formattedData.equals("TRUE")) {
                    bv.setValue(true);
                } else if(formattedData.equals("TRUE")) {
                     bv.setValue(false);
                }
                cell.setValue(formattedData, bv, CellType.BOOLEAN);
            } else if (cellContentType.equals(STRING_CELL_TYPE)) {
                PlainStringValue psv = new PlainStringValue();
                psv.setValue(formattedData);
                cell.setValue(formattedData, psv, CellType.STRING);
            } else if (cellContentType.equals(FORMULA_CELL_TYPE)) {
                PlainStringValue psv = new PlainStringValue();
                psv.setValue(formattedData);
                cell.setValue(formattedData, psv, CellType.FORMULA);
            } else {
                NumericValue nv = new NumericValue();
                nv.setValue(Double.parseDouble(data));
                cell.setValue(formattedData, nv, CellType.NUMERIC);
            }
            row.getCells().add(cell);

        }
    }

    /**
     * Identifies the cell content type
     * 
     * @return
     */
    private String getCellContentType() {
        String cellConentType = DEFAULT_CELL_TYPE;
        String cellType = attributes.get("t");
        if ((null != cellType) && (cellType.equals("s"))) {
            cellConentType = STRING_CELL_TYPE;
        } else if ((null != cellType) && (equals("b"))) {
            cellConentType = BOOLEAN_CELL_TYPE;
        } else {

            if (checkForDate()) {
                cellConentType = DATE_CELL_TYPE;
            } else if (checkForBoolean()) {
                cellConentType = BOOLEAN_CELL_TYPE;
            }
        }
        return cellConentType;
    }

    /**
     * Identifies if the given cell is a boolean or not
     * 
     * @return
     */
    private boolean checkForBoolean() {
        String cellStyleType = attributes.get("s");
        if (cellStyleType != null) {
            int styleIndex = Integer.parseInt(cellStyleType);
            XSSFCellStyle style = stylesTable.getStyleAt(styleIndex);
            formatIndex = style.getDataFormat();
            formatString = style.getDataFormatString();
            if (formatString.contains("TRUE")) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * identifies if the given cell is a Date cell or not
     * 
     * @return
     */
    private boolean checkForDate() {
        boolean isDate = false;
        String cellStyleType = attributes.get("s");
        if (cellStyleType != null) {
            int styleIndex = Integer.parseInt(cellStyleType);
            XSSFCellStyle style = stylesTable.getStyleAt(styleIndex);
            formatIndex = style.getDataFormat();
            formatString = style.getDataFormatString();
            if (dateFormatsAry.contains(formatString.trim())) {
                isDate = true;
            }
        }

        return isDate;
    }

    /**
     * fetches the String data from SharedStringsTable.xml
     * 
     * @param data
     * @return
     */
    private String getStringData(String data) {
        int index = Integer.parseInt(data);
        return new XSSFRichTextString(sharedStringsTable.getEntryAt(index)).toString().trim();
    }

    /**
     * check the styles applied to the cell and fetches the exact content of
     * date cell
     * 
     * @param data
     * @return
     */
    private String getDateAsString(String data) {
        if ((data != null) && (!(data.trim().equals("")))) {
            /*
             * return formatter.formatRawCellContents(Double.parseDouble(data),
             * formatIndex, formatString);
             */

            /*
             * All dates are formatted with 'DD/MM/YYYY', this is to avoid
             * confusion between 10/12/2017 & 10/12/1917. Otherwise both will be
             * read as 10/12/17 if the format is DD/MM/YY
             */
            return formatter.formatRawCellContents(Double.parseDouble(data), formatIndex, "DD/MM/YYYY");
        } else {
            return null;
        }
    }

    /**
     * Used to fill empty cells as null
     */
    private void fillEmptyCells() {
        int currentCellIndex = cellPositions.indexOf(currentCellPosition);
        if ((currentCellIndex - previousCellIndex) > 1) {
            for (int i = (previousCellIndex + 1); i < currentCellIndex; i++) {
                cell = new StreamedCell(row);
                cell.setValue(null, null, CellType.BLANK);
                row.getCells().add(cell);
            }

            previousCellIndex = currentCellIndex;
        }
    }

    public boolean isEndOfRow() {
        return isEndOfRow;
    }

    public void setEndOfRow(boolean isEndOfRow) {
        this.isEndOfRow = isEndOfRow;
    }

    public int getNumberOfColumns() {
        return numberOfColumns;
    }

    public List<String> getCellPositions() {
        return cellPositions;
    }

    public StreamedRow getRow() {
        return row;
    }

}