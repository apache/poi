<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.1//EN"
"../dtd/document-v11.dtd">
<!-- $Id$ -->

<document>
 <header>
  <title>HPSF HOW-TO</title>
  <authors>
   <person name="Rainer Klute" email="klute@apache.org"/>
  </authors>
 </header>
 <body>
  <section title="How To Use the HPSF APIs">

   <p>This HOW-TO is organized in three sections. You should read them
    sequentially because the later sections build upon the earlier ones.</p>

   <ol>
    <li>
     <p>The <link href="#sec1">first section</link> explains how to read
      the most important standard properties of a Microsoft Office
      document. Standard properties are things like title, author, creation
      date etc. It is quite likely that you will find here what you need and
      don't have to read the other sections.</p>
    </li>

    <li>
     <p>The <link href="#sec2">second section</link> goes a small step
      further and focusses on reading additional standard properties. It also
      talks about exceptions that may be thrown when dealing with HPSF and
      shows how you can read properties of embedded objects.</p>
     </li>

    <li>
      <p>The <link href="#sec3">third section</link> tells how to read
      non-standard properties. Non-standard properties are application-specific
      name/value/type triples. <em>This section is still to be written. Look up
      the API documentation for the time being!</em></p>
     </li>
   </ol>



   <anchor id="sec1"/>
   <section title="Reading Standard Properties">

    <note>This section explains how to read
      the most important standard properties of a Microsoft Office
      document. Standard properties are things like title, author, creation
      date etc. Chances are that you will find here what you need and
      don't have to read the other sections.</note>

    <p>The first thing you should understand is that properties are stored in
     separate documents inside the POI filesystem. (If you don't know what a
     POI filesystem is, read the <link href="../poifs/index.html">POIFS
      documentation</link>.)  A document in a POI filesystem is also called a
     <strong>stream</strong>.</p>

    <p>The following example shows how to read a POI filesystem's
     "title" property. Reading other properties is similar. Consider the API
     documentation of <code>org.apache.poi.hpsf.SummaryInformation</code> to
     learn which methods are available!</p>

    <p>The standard properties this section focusses on can be found in a
     document called <em>\005SummaryInformation</em> located in the root of the
     POI filesystem. The notation <em>\005</em> in the document's name means
     the character with the decimal value of 5. In order to read the title, an
     application has to perform the following steps:</p>

    <ol>
     <li>
      <p>Open the document <em>\005SummaryInformation</em> located in the root
       of the POI filesystem.</p>
     </li>
     <li>
      <p>Create an instance of the class <code>SummaryInformation</code> from
       that document.</p>
     </li>
     <li>
      <p>Call the <code>SummaryInformation</code> instance's
       <code>getTitle()</code> method.</p>
     </li>
    </ol>

    <p>Sounds easy, doesn't it? Here are the steps in detail.</p>


    <section title="Open the document \005SummaryInformation in the root of the
       POI filesystem">

     <p>An application that wants to open a document in a POI filesystem
      (POIFS) proceeds as shown by the following code fragment. (The full
      source code of the sample application is available in the
      <em>examples</em> section of the POI source tree as
      <em>ReadTitle.java</em>.</p>

     <source>
import java.io.*;
import org.apache.poi.hpsf.*;
import org.apache.poi.poifs.eventfilesystem.*;

// ...

public static void main(String[] args)
    throws IOException
{
    final String filename = args[0];
    POIFSReader r = new POIFSReader();
    r.registerListener(new MyPOIFSReaderListener(),
                       "\005SummaryInformation");
    r.read(new FileInputStream(filename));
}</source>

     <p>The first interesting statement is</p>

     <source>POIFSReader r = new POIFSReader();</source>

     <p>It creates a
      <code>org.apache.poi.poifs.eventfilesystem.POIFSReader</code> instance
      which we shall need to read the POI filesystem. Before the application
      actually opens the POI filesystem we have to tell the
      <code>POIFSReader</code> which documents we are interested in. In this
      case the application should do something with the document
      <em>\005SummaryInformation</em>.</p>

     <source>
r.registerListener(new MyPOIFSReaderListener(),
                   "\005SummaryInformation");</source>

     <p>This method call registers a
      <code>org.apache.poi.poifs.eventfilesystem.POIFSReaderListener</code>
      with the <code>POIFSReader</code>. The <code>POIFSReaderListener</code>
      interface specifies the method <code>processPOIFSReaderEvent</code>
      which processes a document. The class
      <code>MyPOIFSReaderListener</code> implements the
      <code>POIFSReaderListener</code> and thus the
      <code>processPOIFSReaderEvent</code> method. The eventing POI filesystem
      calls this method when it finds the <em>\005SummaryInformation</em>
      document. In the sample application <code>MyPOIFSReaderListener</code> is
      a static class in the <em>ReadTitle.java</em> source file.</p>

     <p>Now everything is prepared and reading the POI filesystem can
      start:</p>

     <source>r.read(new FileInputStream(filename));</source>

     <p>The following source code fragment shows the
      <code>MyPOIFSReaderListener</code> class and how it retrieves the
      title.</p>

     <source>
static class MyPOIFSReaderListener implements POIFSReaderListener
{
    public void processPOIFSReaderEvent(POIFSReaderEvent event)
    {
        SummaryInformation si = null;
        try
        {
            si = (SummaryInformation)
                 PropertySetFactory.create(event.getStream());
        }
        catch (Exception ex)
        {
            throw new RuntimeException
                ("Property set stream \"" +
                 event.getPath() + event.getName() + "\": " + ex);
        }
        final String title = si.getTitle();
        if (title != null)
            System.out.println("Title: \"" + title + "\"");
        else
            System.out.println("Document has no title.");
    }
}
</source>

     <p>The line</p>

     <source>SummaryInformation si = null;</source>

     <p>declares a <code>SummaryInformation</code> variable and initializes it
      with <code>null</code>. We need an instance of this class to access the
      title. The instance is created in a <code>try</code> block:</p>

     <source>si = (SummaryInformation)
                 PropertySetFactory.create(event.getStream());</source>

     <p>The expression <code>event.getStream()</code> returns the input stream
      containing the bytes of the property set stream named
      <em>\005SummaryInformation</em>. This stream is passed into the
      <code>create</code> method of the factory class
      <code>org.apache.poi.hpsf.PropertySetFactory</code> which returns
      a <code>org.apache.poi.hpsf.PropertySet</code> instance. It is more or
      less safe to cast this result to <code>SummaryInformation</code>, a
      convenience class with methods like <code>getTitle()</code>,
      <code>getAuthor()</code> etc.</p>

     <p>The <code>PropertySetFactory.create</code> method may throw all sorts
      of exceptions. We'll deal with them in the next sections. For now we just
      catch all exceptions and throw a <code>RuntimeException</code>
      containing the message text of the origin exception.</p>

     <p>If all goes well, the sample application retrieves the title and prints
     it to the standard output. As you can see you must be prepared for the
      case that the POI filesystem does not have a title.</p>

     <source>final String title = si.getTitle();
if (title != null)
    System.out.println("Title: \"" + title + "\"");
else
    System.out.println("Document has no title.");</source>

     <p>Please note that a Microsoft Office document does not necessarily
      contain the <em>\005SummaryInformation</em> stream. The documents created
      by the Microsoft Office suite have one, as far as I know. However, an
      Excel spreadsheet exported from StarOffice 5.2 won't have a
      <em>\005SummaryInformation</em> stream. In this case the applications
      won't throw an exception but simply does not call the
      <code>processPOIFSReaderEvent</code> method. You have been warned!</p>
    </section>
   </section>

   <anchor id="sec2"/>
   <section title="Additional Standard Properties, Exceptions And Embedded Objects">

    <note>This section focusses on reading additional standard properties. It
     also talks about exceptions that may be thrown when dealing with HPSF and
     shows how you can read properties of embedded objects.</note>

    <p>A couple of <strong>additional standard properties</strong> are not
     contained in the <em>\005SummaryInformation</em> stream explained above,
     for example a document's category or the number of multimedia clips in a
     PowerPoint presentation. Microsoft has invented an additional stream named
     <em>\005DocumentSummaryInformation</em> to hold these properties. With two
     minor exceptions you can proceed exactly as described above to read the
     properties stored in <em>\005DocumentSummaryInformation</em>:</p>

    <ul>
     <li><p>Instead of <em>\005SummaryInformation</em> use
       <em>\005DocumentSummaryInformation</em> as the stream's name.</p></li>
     <li><p>Replace all occurrences of the class
       <code>SummaryInformation</code> by
       <code>DocumentSummaryInformation</code>.</p></li>
    </ul>

    <p>And of course you cannot call <code>getTitle()</code> because
     <code>DocumentSummaryInformation</code> has different query methods. See
     the Javadoc API documentation for the details!</p>

    <p>In the previous section the application simply caught all
     <strong>exceptions</strong> and was in no way interested in any
     details. However, a real application will likely want to know what went
     wrong and act appropriately. Besides any IO exceptions there are three
     HPSF resp. POI specific exceptions you should know about:</p>

    <dl>
     <dt><code>NoPropertySetStreamException</code>:</dt>
     <dd>
      <p>This exception is thrown if the application tries to create a
       <code>PropertySet</code> instance from a stream that is not a
       property set stream. (<code>SummaryInformation</code> and
       <code>DocumentSummaryInformation</code> are subclasses of
       <code>PropertySet</code>.) A faulty property set stream counts as not
       being a property set stream at all. An application should be prepared to
       deal with this case even if it opens streams named
       <em>\005SummaryInformation</em> or
       <em>\005DocumentSummaryInformation</em> only. These are just names. A
       stream's name by itself does not ensure that the stream contains the
       expected contents and that this contents is correct.</p>
     </dd> 

     <dt><code>UnexpectedPropertySetTypeException</code></dt>
     <dd><p>This exception is thrown if a certain type of property set is
       expected somewhere (e.g. a <code>SummaryInformation</code> or
       <code>DocumentSummaryInformation</code>) but the provided property
       set is not of that type.</p></dd>

     <dt><code>MarkUnsupportedException</code></dt>
     <dd><p>This exception is thrown if an input stream that is to be parsed
       into a property set does not support the
       <code>InputStream.mark(int)</code> operation. The POI filesystem uses
       the <code>DocumentInputStream</code> class which does support this
       operation, so you are safe here. However, if you read a property set
       stream from another kind of input stream things may be
       different.</p></dd>
    </dl>

    <p>Many Microsoft Office documents contain <strong>embedded
      objects</strong>, for example an Excel sheet on a page in a Word
     document. Embedded objects may have property sets of their own. An
     application can open these property set streams as described above. The
     only difference is that they are not located in the POI filesystem's root
     but in a <strong>nested directory</strong> instead. Just register a
     <code>POIFSReaderListener</code> for the property set streams you are
     interested in. For example, the <em>POIBrowser</em> application in the
     contrib section tries to open each and every document in a POI filesystem
     as a property set stream. If this operation was successful it displays the
     properties.</p>
   </section>

   <anchor id="sec3"/>
   <section title="Reading Non-Standard Properties">

    <note>This section tells how to read non-standard properties. Non-standard
     properties are application-specific name/type/value triples.</note>

    <p>Now comes the really hardcode stuff. As mentioned above,
     <code>SummaryInformation</code> and
     <code>DocumentSummaryInformation</code> are just special cases of the
     general concept of a property set. The general concept says that a
     property set consists of <strong>properties</strong>. Each property is an
     entity that has a <strong>name</strong>, a <strong>type</strong>, and a
     <strong>value</strong>.</p>

    <p>Okay, that was still rather easy. However, to make things more
     complicated, Microsoft in its infinite wisdom decided that a property set
     shalt be broken into <strong>sections</strong>. Each section holds a bunch
     of properties. But since that's still not complicated enough: A section
     can optionally have a dictionary that maps property IDs to property
     names - we'll explain later what that means.</p>

    <p>So the procedure to get to the properties is as follows:</p>

    <ol>
     <li>Use the <code>PropertySetFactory</code> to create a
      <code>PropertySet</code> from an input stream. You can try this with any
      input stream: You'll either <code>PropertySet</code> instance or an
      exception is thrown.</li>

     <li>Call the <code>PropertySet</code>'s method <code>getSections()</code>
      to get a list of sections contained in the property set. Each section is
      an instance of the <code>Section</code> class.</li>

     <li>Each section has a format ID. The format ID of the first section in a
      property set determines the property set's type. For example, the first
      (and only) section of the SummaryInformation property set has a format ID
      of <code>F29F85E0-4FF9-1068-AB-91-08-00-2B-27-B3-D9</code>. You can
      get the format ID with <code>Section.getFormatID()</code>.</li>

     <li>The properties contained in a <code>Section</code> can be retrieved
      with <code>Section.getProperties()</code>. The result is an array of
      <code>Property</code> instances.</li>

     <li>A property has a name, a type, and a value. The <code>Property</code>
      class has methods to retrieve them.</li>
    </ol>

    <p>Let's have a look at a sample Java application that dumps all property
     set streams contained in a POI file system. The full source code of this
     program can be found as <em>ReadCustomPropertySets.java</em> in the
     <em>examples</em> area of the POI source code tree. Here are the key
     sections:</p>

    <source>import java.io.*;
import java.util.*;
import org.apache.poi.hpsf.*;
import org.apache.poi.poifs.eventfilesystem.*;
import org.apache.poi.util.HexDump;</source>

    <p>The most important package the application needs is
     <code>org.apache.poi.hpsf.*</code>. This package contains the HPSF
     classes. Most classes named below are from the HPSF package. Of course we
     also need the POIFS event file system's classes and <code>java.io.*</code>
     since we are dealing with POI I/O. From the <code>java.util</code> package
     we use the <code>List</code> and <code>Iterator</code> class. The class
     <code>org.apache.poi.util.HexDump</code> provides a methods to dump byte
     arrays as nicely formatted strings.</p>

    <source>public static void main(String[] args)
    throws IOException
{
    final String filename = args[0];
    POIFSReader r = new POIFSReader();

    /* Register a listener for *all* documents. */
    r.registerListener(new MyPOIFSReaderListener());
    r.read(new FileInputStream(filename));
}</source>

    <p>The <code>POIFSReader</code> is set up in a way that the listener
     <code>MyPOIFSReaderListener</code> is called on every file in the POI file
    system.</p>

    <p>The listener class tries to create a <code>PropertySet</code> from each
     stream using the <code>PropertySetFactory.create()</code> method:</p>

    <source>static class MyPOIFSReaderListener implements POIFSReaderListener
{
    public void processPOIFSReaderEvent(POIFSReaderEvent event)
    {
        PropertySet ps = null;
        try
        {
            ps = PropertySetFactory.create(event.getStream());
        }
        catch (NoPropertySetStreamException ex)
        {
            out("No property set stream: \"" + event.getPath() +
                event.getName() + "\"");
            return;
        }
        catch (Exception ex)
        {
            throw new RuntimeException
                ("Property set stream \"" +
                 event.getPath() + event.getName() + "\": " + ex);
        }

        /* Print the name of the property set stream: */
        out("Property set stream \"" + event.getPath() +
            event.getName() + "\":");</source>

    <p>Creating the <code>PropertySet</code> is done in a <code>try</code>
     block, because not each stream in the POI file system contains a property
     set. If it is some other file, the
     <code>PropertySetFactory.create()</code> throws a
     <code>NoPropertySetStreamException</code>, which is caught and
     logged. Then the program continues with the next stream. However, all
     other types of exceptions cause the program to terminate by throwing a
     runtime exception. If all went well, we can print the name of the property
     set stream.</p>

    <p>The next step is to print the number of sections followed by the
     sections themselves:</p>

    <source>/* Print the number of sections: */
final long sectionCount = ps.getSectionCount();
out("   No. of sections: " + sectionCount);

/* Print the list of sections: */
List sections = ps.getSections();
int nr = 0;
for (Iterator i = sections.iterator(); i.hasNext();)
{
    /* Print a single section: */
    Section sec = (Section) i.next();

    // See below for the complete loop body.
}</source>

    <p>The <code>PropertySet</code>'s method <code>getSectionCount()</code>
     returns the number of sections.</p>

    <p>To retrieve the sections, use the <code>getSections()</code>
     method. This method returns a <code>java.util.List</code> containing
     instances of the <code>Section</code> class in their proper order.</p>

    <p>The sample code shows a loop that retrieves the <code>Section</code>
     objects one by one and prints some information about each one. Here is the
     complete body of the loop:</p>

    <source>/* Print a single section: */
Section sec = (Section) i.next();
out("   Section " + nr++ + ":");
String s = hex(sec.getFormatID().getBytes());
s = s.substring(0, s.length() - 1);
out("      Format ID: " + s);

/* Print the number of properties in this section. */
int propertyCount = sec.getPropertyCount();
out("      No. of properties: " + propertyCount);

/* Print the properties: */
Property[] properties = sec.getProperties();
for (int i2 = 0; i2 &lt; properties.length; i2++)
{
    /* Print a single property: */
    Property p = properties[i2];
    int id = p.getID();
    long type = p.getType();
    Object value = p.getValue();
    out("      Property ID: " + id + ", type: " + type +
        ", value: " + value);
}</source>

    <p>The first method called on the <code>Section</code> instance is
     <code>getFormatID()</code>. As explained above, the format ID of the first
     section in a property set determines the type of the property set. Its
     type is <code>ClassID</code> which is essentially a sequence of 16
     bytes. A real application using its own type of a custom property set
     should have defined a unique format ID and, when reading a property set
     stream, should check the format ID is equal to that unique format ID. The
     sample program just prints the format ID it finds in a section:</p>

    <source>String s = hex(sec.getFormatID().getBytes());
s = s.substring(0, s.length() - 1);
out("      Format ID: " + s);</source>

    <p>As you can see, the <code>getFormatID()</code> method returns a
     <code>ClassID</code> object. An array containing the bytes can be
     retrieved with <code>ClassID.getBytes()</code>. In order to get a nicely
     formatted printout, the sample program uses the <code>hex()</code> helper
     method which in turn uses the POI utility class <code>HexDump</code> in
     the <code>org.apache.poi.util</code> package. Another helper method is
     <code>out()</code> which just saves typing
     <code>System.out.println()</code>.</p>

    <p>Before getting the properties, it is possible to find out how many
     properties are available in the section via the
     <code>Section.getPropertyCount()</code>. The sample application uses this
     method to print the number of properties to the standard output:</p>

    <source>int propertyCount = sec.getPropertyCount();
out("      No. of properties: " + propertyCount);</source>

    <p>Now its time to get to the properties themselves. You can retrieve a
     section's properties with the method
     <code>Section.getProperties()</code>:</p>

    <source>Property[] properties = sec.getProperties();</source>

    <p>As you can see the result is an array of <code>Property</code>
     objects. This class has three methods to retrieve a property's ID, its
     type, and its value. The following code snippet shows how to call
     them:</p>

    <source>for (int i2 = 0; i2 &lt; properties.length; i2++)
{
    /* Print a single property: */
    Property p = properties[i2];
    int id = p.getID();
    long type = p.getType();
    Object value = p.getValue();
    out("      Property ID: " + id + ", type: " + type +
        ", value: " + value);
}</source>

    <p>The output of the sample program might look like the following. It shows
     the summary information and the document summary information property sets
     of a Microsoft Word document. However, unlike the first and second section
     of this HOW-TO the application does not have any code which is specific to
     the <code>SummaryInformation</code> and
     <code>DocumentSummaryInformation</code> classes.</p>

    <source>Property set stream "/SummaryInformation":
   No. of sections: 1
   Section 0:
      Format ID: 00000000 F2 9F 85 E0 4F F9 10 68 AB 91 08 00 2B 27 B3 D9 ....O..h....+'..
      No. of properties: 17
      Property ID: 1, type: 2, value: 1252
      Property ID: 2, type: 30, value: Titel
      Property ID: 3, type: 30, value: Thema
      Property ID: 4, type: 30, value: Rainer Klute (Autor)
      Property ID: 5, type: 30, value: Test (Stichwörter)
      Property ID: 6, type: 30, value: This is a document for testing HPSF
      Property ID: 7, type: 30, value: Normal.dot
      Property ID: 8, type: 30, value: Unknown User
      Property ID: 9, type: 30, value: 3
      Property ID: 18, type: 30, value: Microsoft Word 9.0
      Property ID: 12, type: 64, value: Mon Jan 01 00:59:25 CET 1601
      Property ID: 13, type: 64, value: Thu Jul 18 16:22:00 CEST 2002
      Property ID: 14, type: 3, value: 1
      Property ID: 15, type: 3, value: 20
      Property ID: 16, type: 3, value: 93
      Property ID: 19, type: 3, value: 0
      Property ID: 17, type: 71, value: [B@13582d
Property set stream "/DocumentSummaryInformation":
   No. of sections: 2
   Section 0:
      Format ID: 00000000 D5 CD D5 02 2E 9C 10 1B 93 97 08 00 2B 2C F9 AE ............+,..
      No. of properties: 14
      Property ID: 1, type: 2, value: 1252
      Property ID: 2, type: 30, value: Test
      Property ID: 14, type: 30, value: Rainer Klute (Manager)
      Property ID: 15, type: 30, value: Rainer Klute IT-Consulting GmbH
      Property ID: 5, type: 3, value: 3
      Property ID: 6, type: 3, value: 2
      Property ID: 17, type: 3, value: 111
      Property ID: 23, type: 3, value: 592636
      Property ID: 11, type: 11, value: false
      Property ID: 16, type: 11, value: false
      Property ID: 19, type: 11, value: false
      Property ID: 22, type: 11, value: false
      Property ID: 13, type: 4126, value: [B@56a499
      Property ID: 12, type: 4108, value: [B@506411
   Section 1:
      Format ID: 00000000 D5 CD D5 05 2E 9C 10 1B 93 97 08 00 2B 2C F9 AE ............+,..
      No. of properties: 7
      Property ID: 0, type: 0, value: {6=Test-JaNein, 5=Test-Zahl, 4=Test-Datum, 3=Test-Text, 2=_PID_LINKBASE}
      Property ID: 1, type: 2, value: 1252
      Property ID: 2, type: 65, value: [B@c9ba38
      Property ID: 3, type: 30, value: This is some text.
      Property ID: 4, type: 64, value: Wed Jul 17 00:00:00 CEST 2002
      Property ID: 5, type: 3, value: 27
      Property ID: 6, type: 11, value: true
No property set stream: "/WordDocument"
No property set stream: "/CompObj"
No property set stream: "/1Table"</source>

    <p>There are some interestion items to note:</p>

    <ul>
     <li>The first property set (summary information) consists of a single
       section, the second property set (document summary information) consists
       of two sections.</li>

     <li>Each section type (identified by its format ID) has its own domain of
      property ID. For example, in the second property set the properties with
      ID 2 have different meanings in the two section. By the way, the format
      IDs of these sections are <strong>not</strong> equal, but you have to
      look hard to find the difference.</li>

     <li>The properties are not in any particular order in the section,
      although they slightly tend to be sorted by their IDs.</li>
    </ul>

    <note>[To be continued.]</note>

    <note>A last note: There are still some aspects of HSPF left which are not
     documented in this HOW-TO. You should dig into the Javadoc API
     documentation to learn further details. Since you struggled through this
     document up to this point, you are well prepared.</note>
   </section>
  </section>
 </body>
</document>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
